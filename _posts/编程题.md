---
title: "编程题"
excerpt: "手写编程题"
coverImage: "${basePath}/assets/blog/hello-world/cover.jpg"
date: "2020-03-16T05:35:07.322Z"
author:
  name: "Hebe Huang"
  picture: "${basePath}/assets/blog/authors/hebe.avif"
ogImage:
  url: "${basePath}/assets/blog/hello-world/cover.jpg"
---

# 1、如何实现一个bind?
```javascript
Function.prototype.myBind = function(context) {
    if (typeof this !== function) {
        throw new TypeError('Error')
    }
    let args = [...arguments].slice(1),
        fn = this;
    return function Fn() {
        return fn.apply(this instanceof Fn ? new Fn(...arguments)) : context, args.concat(...arguments)))
    }
}
```

# 2. 怎么实现浅拷贝
```javascript
fuction shadowClone(obj){
    let newObj = {}
    // 遍历传入对象的所有可枚举属性
    for(let prop in obj) {
        // 判断属性是否是对象自身的属性，而不是原型链上的
        if (obj.hasOwnProperty(prop)) {
            // 将该属性及其对应值复制到新对象中
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}
```

# 3. 怎么实现深拷贝
```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

# 4, 用js实现二叉树的定义和基本操作
```javascript
class Node{
    constructor(data, left, right){
        this.data = data;
        this.left = left;
        this.right = right;
        this.count = 1;
    }
}
```
```javascript
class BSTree {
    constructor() {
        this.root = null
    }

    // 删除一个节点
    _removeNode(node, data){
        if (node === null) {
            return null;
        }
        if (data === node.data) {
            // 叶子节点
            if (node.left === null && node.right === null) {
                return null;
            }

            // 没有左节点的节点
            if (node.left === null) return node.right

            // 没有右节点的节点
            if (node.right === null) return node.left

            // 有两个节点的节点
            /**
             * 做法：
             * 找到待删除节点的右子树上的最小值创建一个临时节点。
             * 将临时节点上的值复制到待删除节点，然后再删除临时节点
             * 
            */

            // 寻找右子树上的最小值
            let tempNode = getMinNode(node.right);
            node.data = tempNode.data;
            node.right = this._removeNode(node.right, tempNode.data)
            return node;
        } else if (data < node.data) {
            node.left = this._removeNode(node.left, data)
            return node;
        } else {
            node.right = this._removeNode(node.right, data);
            return node;
        }
    }

    // 删除给定的数据节点
    remove(data) {
        this.root = this._removeNode(this.root, data)
    }

    // 向二叉树中插入节点
    insert(data){
        let newNode = new Node(data, null, null);
        if (this.root === null) {
            this.root = newNode;
        } else {
            let currentNode = this.root;
            let parentNode = null
            while(true) {
                parentNode = currentNode;
                if (newNode.data < currentNode.data) {
                    currentNode = currentNode.left;
                    if (!currentNode) {
                        parentNode.left = newNode
                        break;
                    }
                } else if (newNode.data > currentNode.data) {
                    currentNode = currentNode.right;
                    if (!currentNode) {
                        parentNode.right = newNode
                        break;
                    }
                } else {
                    currentNode.count++
                    break;
                }
            }
        }
    }

    // 寻找给定数据的节点
    find(data) {
        let currentNode = this.root;
        while(currentNode) {
            if (data < currentNode.left) {
                currentNode = currentNode.left;
            } else if (data > currentNode.right) {
                currentNode = currentNode.right;
            } else {
                return currentNode
            }
        }
        return null
    }

    // 获得最小值的节点
    getMinNode(node = this.root){
        let currentNode = node;
        while(currentNode.left) {
            currentNode = currentNode.left;
        }
        return currentNode
    }

    // 获得最大值的节点
    getMaxNode(node = this.root){
        let currentNode = node;
        while(currentNode.right) {
            currentNode = currentNode.right;
        }
        return currentNode
    }
}
```
[链接](https://fe.ecool.fun/topic/68c29b20-6b2f-4efa-b6f7-772cc7958084?orderBy=updateTime&order=desc&tagId=26)

# 5 请手写“选择排序”
```javascript
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    console.time('选择排序耗时');
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    console.timeEnd('选择排序耗时');
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```

# 6 冒泡排序
```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for(let i = 0; i < n; i++) {
        let changed = false;
        for (let j = 0; j < n - 1 -i; j++) {
            if (arr[j] > arr[j+1]) {
                changed = true;
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
            }
        }
        if (!changed) {
            break;
        }
    }
    return arr;
}
```
```c
void bubble_sort(int arr[], int length) {
    for(let i = length; i >1; i--) {
        int swapped = 0;
        for(let j = 1; j < i; j++) {
            if (arr[j-1] > arr[j]) {
                swap(&arr[j-1], &arr[j]);
                swapped = 1;
            }
        }
        if (!swapped) break;
    }
}
```

# 7，计数排序
```javascript
function countingSort(arr) {
    var len = arr.length,
        b = []
        c = [],
        min = max = arr[0]
    for(let i = 0; i < arr.length; i++) {
        min = min > arr[i] ? arr[i] : min;
        max = max < arr[i] ? arr[i] : max;
        c[arr[i]] = c[arr[i]] ? c[arr[i]] + 1 : 1;
    }
    for(let i = min; i < max; i++) {
        c[i+1] = (c[i+1] || 0) + (c[i] || 0)
    }
    for (let i = 0; i < arr.length; i++) {
        b[c[arr[i]] - 1] = arr[i]
        c[arr[i]]--
    }
    return b;
}
```

# 8, 写出一个函数trans，将数字转换成汉语的输出，输入为不超过10000亿的数字
```javascript
function trans(num) {
    const str = num.toString();
    const n = str.length;
    const result = [];
    const units = ['', '十', '百', '千', '万', '十', '百', '千', '亿', '十', '百', '千'];
    const digits = '零一二三四五六七八九';

    if (num == 0) {
        return '零';
    }

    for(let i = 0; i < n; i++) {
        const digit = Number(str[i]);
        if (digit !== 0) {
            result.push(digits[digit])
            result.push(units[n - i - 1])
        } else {
            if(result.length > 0 && result[result.length - 1] !== '零') {
                result.push('零')
            }
        }
    }

    // 去掉多个零
    while (result[result.length - 1] === '零'){
        result.pop();
    }

    return result.join('')
}

console.log(trans(123456789012))
console.log(trans(1000))
console.log(trans(1050))
console.log(trans(10000))
console.log(trans(10001))
```

# 9, 使用Promise实现每隔1秒输出1,2,3
```javascript
function printNumInterval(arr) {
    arr.reduce((p, c) => {
        return p.then(() => {
            return new Promise(r => {
                setTimeout(() => {
                    r(console.log(c));
 nntyyp-0[;]                }, 1000)
            })
        })
    }, Promise.resolve())
}
printNums([1,2,3,4,5,6,7,8])
```

# 10, 第37题：实现mergePromise函数
实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。

```javascript
const time = (timer) => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve()
    }, timer)
  })
}
const ajax1 = () => time(2000).then(() => {
  console.log(1);
  return 1
})
const ajax2 = () => time(1000).then(() => {
  console.log(2);
  return 2
})
const ajax3 = () => time(1000).then(() => {
  console.log(3);
  return 3
})

function mergePromise () {
  // 在这里写代码
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log("done");
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]

```

```javascript
function mergePromise (arr) {
  // 在这里写代码
  const data = []
  return arr.reduce((p, c) => {
    return p.then(c)
            .then(d => {
                data.push(d); 
                return data;
                })
  }, Promise.resolve())
  .then(() => data)
}
```

# 11 第38题：使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部
有8个图片资源的url，已经存储在数组urls中。

urls类似于['https://image1.png', 'https://image2.png', ....]

而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。

但有一个要求，任何时刻同时下载的链接数量不可以超过3个。

请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。

```javascript
var urls = [
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png",
];
function loadImg(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function() {
      console.log("一张图片加载完成");
      resolve(img);
    };
    img.onerror = function() {
    	reject(new Error('Could not load image at' + url));
    };
    img.src = url;
  });
  ```

  # 12 写一个 repeat 方法，实现字符串的复制拼接

  ```javascript
  function repeat(target, n) {
    return (new Array(n + 1)).join(target)
  }

  function repeat(target, n) {
    return Array.prototype.join.call({
        length: n + 1
    }, target)
  }

  if(!String.prototype.repeat) {
    String.prototype.repeat = function(count) {
        'use strict';
        if (this === null) {
            throw new TypeError('can\'t convert ' + this + 'to object');
        }
        var str = '' + this;
        // To convert string to integer
        count = +count;
        // Check NaN
        if (count != count) {
            count = 0
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative')
        }

        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }

        count = Math.floor(count);
        if (str.length == 0 || count ==0) {
            return ''
        }

        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28)
        throw new RangeError('repeat count must not overflow maximum string size');

        var maxCount = str.length * count;
        count = Math.floor(Math.log(count)/Math.log(2));
        while(count) {
            str += str;
            count--
        }
        str += str.substring(0, maxCount - str.length)
        return str;
    }
  }
  ```

# 13 第41题：使用js实现二分查找
二分查找，也称为折半查找，是指在有序的数组里找出指定的值，返回该值在数组中的索引。

查找步骤如下：

从有序数组的最中间元素开始查找，如果该元素正好是指定查找的值，则查找过程结束。否则进行下一步;
如果指定要查找的元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作;
重复以上过程，直到找到目标元素的索引，查找成功;或者直到子数组为空，查找失败。
优点是比较次数少，查找速度快，平均性能好； 其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。

## 非递归
```javascript
// arr 数组； key:查找的元素
function search(arr, key) {
    // 初始索引开始位置和结束位置
    var start = 0,
        end = arr.length - 1;
    while(start <= end) {
        // 取上限和下限中间的索引
        var mid = parseInt((start + end) / 2);
        if (key === arr[mid]) {
            return mid;
        } else if (key > arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return -1;
}
var arr = [0,13,21,35,46,52,68,77,89,94];
search(arr, 68); //6
search(arr, 1); //-1
```

## 递归
```javascript
// arr: 数组；key:查找的元素;start:开始索引;end:结束索引
function search2(arr, key, start, end) {
    //首先判断当前起始索引是否大于结束索引,如果大于说明没有找到元素返回-1
    if (start > end) {
        return -1;
    }

    //如果手动调用不写start和end参数会当做第一次运行默认值
    //三元表达式:如果不写end参数则为undefined说明第一次调用所以结束索引为arr.length-1
    //如果是递归调用则使用传进来的参数end值
    var end = end === undefined ? arr.length - 1 : end;
    //如果 || 前面的为真则赋值start,如果为假则赋值后面的0
    //所以end变量没有写var end = end || arr.length-1;这样如果递归调用时候传参end为0时会被转化为false,导致赋值给arr.length-1造成无限循环溢出;
    var start = start || 0;

    // 取上限和下限中间的索引
    var mid = parseInt((start + end) / 2);
    if (key === arr[mid]) {
        //如果找到则直接返回
        return mid;
    } else if (key > arr[mid]) {
        return search2(arr, key, mid + 1, end);
    } else {
        return search2(arr, key, start, mid - 1);
    }
}
var arr = [0,13,21,35,46,52,68,77,89,94];
search2(arr, 77); //7
search2(arr, 99); //-1
```

# 14 第44题：使用Promise实现红绿灯交替重复亮
红灯3秒亮一次，绿灯2秒亮一次，黄灯1秒亮一次；如何让三个灯不断交替重复亮灯？

要求：用Promise实现

三个亮灯函数已经存在：

```javascript
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
function light(time, callback) {
    return new Promise((resolve) => {
        callback();
        setTimeout(() => {
            resolve()
        }, time)
    })
}
function step() {
    Promise.resolve().then(() => {
        return light(3000, red)
    }).then(() => {
        return light(2000, green)
    }).then(() => {
        return light(1000, yellow)
    }).then(() => {
        step()
    })
}
step()
```

# 15 第45题：利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3
```javascript
function compressedString(str) {
    let count = 1;
    let res = '';
    for(let i = 0; i < str.length; i++) {
        if (str[i] === str[i+1]) {
            count++
        } else {
            res += `${str[i]}${count}`
            count = 1;
        }
    }
    return res;
}
compressedString('aabcccccaaa')
```

# 16, 将下面的数组转成树状结构
根据 id 和 parent_id 的对应关系，进行下面的转换。
原始数据：
```javascript
[
  { "id": 12, "parent_id": 1, "name": "朝阳区" },
  { "id": 241, "parent_id": 24, "name": "田林街道" },
  { "id": 31, "parent_id": 3, "name": "广州市" },
  { "id": 13, "parent_id": 1, "name": "昌平区" },
  { "id": 2421, "parent_id": 242, "name": "上海科技绿洲" },
  { "id": 21, "parent_id": 2, "name": "静安区" },
  { "id": 242, "parent_id": 24, "name": "漕河泾街道" },
  { "id": 22, "parent_id": 2, "name": "黄浦区" },
  { "id": 11, "parent_id": 1, "name": "顺义区" },
  { "id": 2, "parent_id": 0, "name": "上海市" },
  { "id": 24, "parent_id": 2, "name": "徐汇区" },
  { "id": 1, "parent_id": 0, "name": "北京市" },
  { "id": 2422, "parent_id": 242, "name": "漕河泾开发区" },
  { "id": 32, "parent_id": 3, "name": "深圳市" },
  { "id": 33, "parent_id": 3, "name": "东莞市" },
  { "id": 3, "parent_id": 0, "name": "广东省" }
]
function convertTree(arr) {
    let map = new Map();
    for(let i = 0; i < arr.length; i++) {
        const city = arr[i];
        map.set(city['id'], {...city, children: []})
    }
    let res = []
    for(let [key, value] of map) {
        console.log({key, value})
        const parKey = value.parent_id
        if (parKey === 0) {
            res.push(value)
        } else {
            const par = map.get(parKey);
            par.children.push(value)
        }
    }
    return res;
}

```

## 方法二
```javascript
/**
 * 数组转树形结构
 * @param {array} list 被转换的数组
 * @param {number|string} root 根节点（最外层节点）
 * @returns array
 */
function arrayToTree(list, root) {
  return list
    .filter(item => item.parent_id === root)
    .map(item => ({ ...item, children: arrayToTree(list, item.id) }))
}
```
代码很简洁，filter 和 map 方法也是数组中很常见的方法，相信大家也很好理解。

## 方法二
可以利用浅拷贝是拷贝对象的内存地址的特性，我们修改拷贝后，所有引用都会同步修改。利用这个特点，我们将子节点依次放入父节点，最后将最外层父节点返回即可。
```javascript
/**
 * 数组转树形结构
 * @param {array} list被转换的数组
 * @param {number|string} root跟节点,最外层节点的id
 * @return array
 * */
 function arrayToTree(list, root) {
    const result = []; // 用于存放结果
    const map = {} // 用于存放list 下的节点

    // 1. 遍历list, 将list下的所有节点以id作为索引存入map
    for(const item of list) {
        map[item.id] = {...item, children: []}
    }

    // 2. 再次遍历，将根节点放入最外层，子节点放入父节点
    for(const item of list) {
        // 3. 获取节点的id和parent id
        const { id, parent_id } = item;
        // 4. 如果是跟节点，存入result
        if (parent_id === root) {
            result.push(map[id])
        } else {
            map[parent_id].children.push(map[id])
        }
    }
    return result;
 }
```

Venenatis cras sed felis eget velit. Consectetur libero id faucibus nisl tincidunt. Gravida in fermentum et sollicitudin ac orci phasellus egestas tellus. Volutpat consequat mauris nunc congue nisi vitae. Id aliquet risus feugiat in ante metus dictum at tempor. Sed blandit libero volutpat sed cras. Sed odio morbi quis commodo odio aenean sed adipiscing. Velit euismod in pellentesque massa placerat. Mi bibendum neque egestas congue quisque egestas diam in arcu. Nisi lacus sed viverra tellus in. Nibh cras pulvinar mattis nunc sed. Luctus accumsan tortor posuere ac ut consequat semper viverra. Fringilla ut morbi tincidunt augue interdum velit euismod.

## Lorem Ipsum

Tristique senectus et netus et malesuada fames ac turpis. Ridiculous mus mauris vitae ultricies leo integer malesuada nunc vel. In mollis nunc sed id semper. Egestas tellus rutrum tellus pellentesque. Phasellus vestibulum lorem sed risus ultricies tristique nulla. Quis blandit turpis cursus in hac habitasse platea dictumst quisque. Eros donec ac odio tempor orci dapibus ultrices. Aliquam sem et tortor consequat id porta nibh. Adipiscing elit duis tristique sollicitudin nibh sit amet commodo nulla. Diam vulputate ut pharetra sit amet. Ut tellus elementum sagittis vitae et leo. Arcu non odio euismod lacinia at quis risus sed vulputate.
