---
title: "编程题"
excerpt: "手写编程题"
coverImage: "${basePath}/assets/blog/hello-world/cover.jpg"
date: "2020-03-16T05:35:07.322Z"
author:
  name: "Hebe Huang"
  picture: "${basePath}/assets/blog/authors/hebe.avif"
ogImage:
  url: "${basePath}/assets/blog/hello-world/cover.jpg"
---

# 1、如何实现一个bind?
```javascript
Function.prototype.myBind = function(context) {
    if (typeof this !== function) {
        throw new TypeError('Error')
    }
    let args = [...arguments].slice(1),
        fn = this;
    return function Fn() {
        return fn.apply(this instanceof Fn ? new Fn(...arguments)) : context, args.concat(...arguments)))
    }
}
```

# 2. 怎么实现浅拷贝
```javascript
fuction shadowClone(obj){
    let newObj = {}
    // 遍历传入对象的所有可枚举属性
    for(let prop in obj) {
        // 判断属性是否是对象自身的属性，而不是原型链上的
        if (obj.hasOwnProperty(prop)) {
            // 将该属性及其对应值复制到新对象中
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}
```

# 3. 怎么实现深拷贝
```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

# 4, 用js实现二叉树的定义和基本操作
```javascript
class Node{
    constructor(data, left, right){
        this.data = data;
        this.left = left;
        this.right = right;
        this.count = 1;
    }
}
```
```javascript
class BSTree {
    constructor() {
        this.root = null
    }

    // 删除一个节点
    _removeNode(node, data){
        if (node === null) {
            return null;
        }
        if (data === node.data) {
            // 叶子节点
            if (node.left === null && node.right === null) {
                return null;
            }

            // 没有左节点的节点
            if (node.left === null) return node.right

            // 没有右节点的节点
            if (node.right === null) return node.left

            // 有两个节点的节点
            /**
             * 做法：
             * 找到待删除节点的右子树上的最小值创建一个临时节点。
             * 将临时节点上的值复制到待删除节点，然后再删除临时节点
             * 
            */

            // 寻找右子树上的最小值
            let tempNode = getMinNode(node.right);
            node.data = tempNode.data;
            node.right = this._removeNode(node.right, tempNode.data)
            return node;
        } else if (data < node.data) {
            node.left = this._removeNode(node.left, data)
            return node;
        } else {
            node.right = this._removeNode(node.right, data);
            return node;
        }
    }

    // 删除给定的数据节点
    remove(data) {
        this.root = this._removeNode(this.root, data)
    }

    // 向二叉树中插入节点
    insert(data){
        let newNode = new Node(data, null, null);
        if (this.root === null) {
            this.root = newNode;
        } else {
            let currentNode = this.root;
            let parentNode = null
            while(true) {
                parentNode = currentNode;
                if (newNode.data < currentNode.data) {
                    currentNode = currentNode.left;
                    if (!currentNode) {
                        parentNode.left = newNode
                        break;
                    }
                } else if (newNode.data > currentNode.data) {
                    currentNode = currentNode.right;
                    if (!currentNode) {
                        parentNode.right = newNode
                        break;
                    }
                } else {
                    currentNode.count++
                    break;
                }
            }
        }
    }

    // 寻找给定数据的节点
    find(data) {
        let currentNode = this.root;
        while(currentNode) {
            if (data < currentNode.left) {
                currentNode = currentNode.left;
            } else if (data > currentNode.right) {
                currentNode = currentNode.right;
            } else {
                return currentNode
            }
        }
        return null
    }

    // 获得最小值的节点
    getMinNode(node = this.root){
        let currentNode = node;
        while(currentNode.left) {
            currentNode = currentNode.left;
        }
        return currentNode
    }

    // 获得最大值的节点
    getMaxNode(node = this.root){
        let currentNode = node;
        while(currentNode.right) {
            currentNode = currentNode.right;
        }
        return currentNode
    }
}
```
[链接](https://fe.ecool.fun/topic/68c29b20-6b2f-4efa-b6f7-772cc7958084?orderBy=updateTime&order=desc&tagId=26)

# 5 请手写“选择排序”
```javascript
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    console.time('选择排序耗时');
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    console.timeEnd('选择排序耗时');
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```

# 6 冒泡排序
```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for(let i = 0; i < n; i++) {
        let changed = false;
        for (let j = 0; j < n - 1 -i; j++) {
            if (arr[j] > arr[j+1]) {
                changed = true;
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
            }
        }
        if (!changed) {
            break;
        }
    }
    return arr;
}
```
```c
void bubble_sort(int arr[], int length) {
    for(let i = length; i >1; i--) {
        int swapped = 0;
        for(let j = 1; j < i; j++) {
            if (arr[j-1] > arr[j]) {
                swap(&arr[j-1], &arr[j]);
                swapped = 1;
            }
        }
        if (!swapped) break;
    }
}
```

# 7，计数排序
```javascript
function countingSort(arr) {
    var len = arr.length,
        b = []
        c = [],
        min = max = arr[0]
    for(let i = 0; i < arr.length; i++) {
        min = min > arr[i] ? arr[i] : min;
        max = max < arr[i] ? arr[i] : max;
        c[arr[i]] = c[arr[i]] ? c[arr[i]] + 1 : 1;
    }
    for(let i = min; i < max; i++) {
        c[i+1] = (c[i+1] || 0) + (c[i] || 0)
    }
    for (let i = 0; i < arr.length; i++) {
        b[c[arr[i]] - 1] = arr[i]
        c[arr[i]]--
    }
    return b;
}
```

# 8, 写出一个函数trans，将数字转换成汉语的输出，输入为不超过10000亿的数字
```javascript
function trans(num) {
    const str = num.toString();
    const n = str.length;
    const result = [];
    const units = ['', '十', '百', '千', '万', '十', '百', '千', '亿', '十', '百', '千'];
    const digits = '零一二三四五六七八九';

    if (num == 0) {
        return '零';
    }

    for(let i = 0; i < n; i++) {
        const digit = Number(str[i]);
        if (digit !== 0) {
            result.push(digits[digit])
            result.push(units[n - i - 1])
        } else {
            if(result.length > 0 && result[result.length - 1] !== '零') {
                result.push('零')
            }
        }
    }

    // 去掉多个零
    while (result[result.length - 1] === '零'){
        result.pop();
    }

    return result.join('')
}

console.log(trans(123456789012))
console.log(trans(1000))
console.log(trans(1050))
console.log(trans(10000))
console.log(trans(10001))
```

# 9, 使用Promise实现每隔1秒输出1,2,3
```javascript
function printNumInterval(arr) {
    arr.reduce((p, c) => {
        return p.then(() => {
            return new Promise(r => {
                setTimeout(() => {
                    r(console.log(c));
 nntyyp-0[;]                }, 1000)
            })
        })
    }, Promise.resolve())
}
printNums([1,2,3,4,5,6,7,8])
```

# 10, 第37题：实现mergePromise函数
实现mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中。

```javascript
const time = (timer) => {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve()
    }, timer)
  })
}
const ajax1 = () => time(2000).then(() => {
  console.log(1);
  return 1
})
const ajax2 = () => time(1000).then(() => {
  console.log(2);
  return 2
})
const ajax3 = () => time(1000).then(() => {
  console.log(3);
  return 3
})

function mergePromise () {
  // 在这里写代码
}

mergePromise([ajax1, ajax2, ajax3]).then(data => {
  console.log("done");
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]

```

```javascript
function mergePromise (arr) {
  // 在这里写代码
  const data = []
  return arr.reduce((p, c) => {
    return p.then(c)
            .then(d => {
                data.push(d); 
                return data;
                })
  }, Promise.resolve())
  .then(() => data)
}
```

# 11 第38题：使用Promise实现：限制异步操作的并发个数，并尽可能快的完成全部
有8个图片资源的url，已经存储在数组urls中。

urls类似于['https://image1.png', 'https://image2.png', ....]

而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。

但有一个要求，任何时刻同时下载的链接数量不可以超过3个。

请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。

```javascript
var urls = [
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png",
  "https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png",
];
function loadImg(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = function() {
      console.log("一张图片加载完成");
      resolve(img);
    };
    img.onerror = function() {
    	reject(new Error('Could not load image at' + url));
    };
    img.src = url;
  });
  ```

  # 12 写一个 repeat 方法，实现字符串的复制拼接

  ```javascript
  function repeat(target, n) {
    return (new Array(n + 1)).join(target)
  }

  function repeat(target, n) {
    return Array.prototype.join.call({
        length: n + 1
    }, target)
  }

  if(!String.prototype.repeat) {
    String.prototype.repeat = function(count) {
        'use strict';
        if (this === null) {
            throw new TypeError('can\'t convert ' + this + 'to object');
        }
        var str = '' + this;
        // To convert string to integer
        count = +count;
        // Check NaN
        if (count != count) {
            count = 0
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative')
        }

        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }

        count = Math.floor(count);
        if (str.length == 0 || count ==0) {
            return ''
        }

        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (str.length * count >= 1 << 28)
        throw new RangeError('repeat count must not overflow maximum string size');

        var maxCount = str.length * count;
        count = Math.floor(Math.log(count)/Math.log(2));
        while(count) {
            str += str;
            count--
        }
        str += str.substring(0, maxCount - str.length)
        return str;
    }
  }
  ```

# 13 第41题：使用js实现二分查找
二分查找，也称为折半查找，是指在有序的数组里找出指定的值，返回该值在数组中的索引。

查找步骤如下：

从有序数组的最中间元素开始查找，如果该元素正好是指定查找的值，则查找过程结束。否则进行下一步;
如果指定要查找的元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作;
重复以上过程，直到找到目标元素的索引，查找成功;或者直到子数组为空，查找失败。
优点是比较次数少，查找速度快，平均性能好； 其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。

## 非递归
```javascript
// arr 数组； key:查找的元素
function search(arr, key) {
    // 初始索引开始位置和结束位置
    var start = 0,
        end = arr.length - 1;
    while(start <= end) {
        // 取上限和下限中间的索引
        var mid = parseInt((start + end) / 2);
        if (key === arr[mid]) {
            return mid;
        } else if (key > arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return -1;
}
var arr = [0,13,21,35,46,52,68,77,89,94];
search(arr, 68); //6
search(arr, 1); //-1
```

## 递归
```javascript
// arr: 数组；key:查找的元素;start:开始索引;end:结束索引
function search2(arr, key, start, end) {
    //首先判断当前起始索引是否大于结束索引,如果大于说明没有找到元素返回-1
    if (start > end) {
        return -1;
    }

    //如果手动调用不写start和end参数会当做第一次运行默认值
    //三元表达式:如果不写end参数则为undefined说明第一次调用所以结束索引为arr.length-1
    //如果是递归调用则使用传进来的参数end值
    var end = end === undefined ? arr.length - 1 : end;
    //如果 || 前面的为真则赋值start,如果为假则赋值后面的0
    //所以end变量没有写var end = end || arr.length-1;这样如果递归调用时候传参end为0时会被转化为false,导致赋值给arr.length-1造成无限循环溢出;
    var start = start || 0;

    // 取上限和下限中间的索引
    var mid = parseInt((start + end) / 2);
    if (key === arr[mid]) {
        //如果找到则直接返回
        return mid;
    } else if (key > arr[mid]) {
        return search2(arr, key, mid + 1, end);
    } else {
        return search2(arr, key, start, mid - 1);
    }
}
var arr = [0,13,21,35,46,52,68,77,89,94];
search2(arr, 77); //7
search2(arr, 99); //-1
```

# 14 第44题：使用Promise实现红绿灯交替重复亮
红灯3秒亮一次，绿灯2秒亮一次，黄灯1秒亮一次；如何让三个灯不断交替重复亮灯？

要求：用Promise实现

三个亮灯函数已经存在：

```javascript
function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
function light(time, callback) {
    return new Promise((resolve) => {
        callback();
        setTimeout(() => {
            resolve()
        }, time)
    })
}
function step() {
    Promise.resolve().then(() => {
        return light(3000, red)
    }).then(() => {
        return light(2000, green)
    }).then(() => {
        return light(1000, yellow)
    }).then(() => {
        step()
    })
}
step()
```

# 15 第45题：利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3
```javascript
function compressedString(str) {
    let count = 1;
    let res = '';
    for(let i = 0; i < str.length; i++) {
        if (str[i] === str[i+1]) {
            count++
        } else {
            res += `${str[i]}${count}`
            count = 1;
        }
    }
    return res;
}
compressedString('aabcccccaaa')
```

# 16, 将下面的数组转成树状结构
根据 id 和 parent_id 的对应关系，进行下面的转换。
原始数据：
```javascript
[
  { "id": 12, "parent_id": 1, "name": "朝阳区" },
  { "id": 241, "parent_id": 24, "name": "田林街道" },
  { "id": 31, "parent_id": 3, "name": "广州市" },
  { "id": 13, "parent_id": 1, "name": "昌平区" },
  { "id": 2421, "parent_id": 242, "name": "上海科技绿洲" },
  { "id": 21, "parent_id": 2, "name": "静安区" },
  { "id": 242, "parent_id": 24, "name": "漕河泾街道" },
  { "id": 22, "parent_id": 2, "name": "黄浦区" },
  { "id": 11, "parent_id": 1, "name": "顺义区" },
  { "id": 2, "parent_id": 0, "name": "上海市" },
  { "id": 24, "parent_id": 2, "name": "徐汇区" },
  { "id": 1, "parent_id": 0, "name": "北京市" },
  { "id": 2422, "parent_id": 242, "name": "漕河泾开发区" },
  { "id": 32, "parent_id": 3, "name": "深圳市" },
  { "id": 33, "parent_id": 3, "name": "东莞市" },
  { "id": 3, "parent_id": 0, "name": "广东省" }
]
function convertTree(arr) {
    let map = new Map();
    for(let i = 0; i < arr.length; i++) {
        const city = arr[i];
        map.set(city['id'], {...city, children: []})
    }
    let res = []
    for(let [key, value] of map) {
        console.log({key, value})
        const parKey = value.parent_id
        if (parKey === 0) {
            res.push(value)
        } else {
            const par = map.get(parKey);
            par.children.push(value)
        }
    }
    return res;
}

```

## 方法二
```javascript
/**
 * 数组转树形结构
 * @param {array} list 被转换的数组
 * @param {number|string} root 根节点（最外层节点）
 * @returns array
 */
function arrayToTree(list, root) {
  return list
    .filter(item => item.parent_id === root)
    .map(item => ({ ...item, children: arrayToTree(list, item.id) }))
}
```
代码很简洁，filter 和 map 方法也是数组中很常见的方法，相信大家也很好理解。

## 方法二
可以利用浅拷贝是拷贝对象的内存地址的特性，我们修改拷贝后，所有引用都会同步修改。利用这个特点，我们将子节点依次放入父节点，最后将最外层父节点返回即可。
```javascript
/**
 * 数组转树形结构
 * @param {array} list被转换的数组
 * @param {number|string} root跟节点,最外层节点的id
 * @return array
 * */
 function arrayToTree(list, root) {
    const result = []; // 用于存放结果
    const map = {} // 用于存放list 下的节点

    // 1. 遍历list, 将list下的所有节点以id作为索引存入map
    for(const item of list) {
        map[item.id] = {...item, children: []}
    }

    // 2. 再次遍历，将根节点放入最外层，子节点放入父节点
    for(const item of list) {
        // 3. 获取节点的id和parent id
        const { id, parent_id } = item;
        // 4. 如果是跟节点，存入result
        if (parent_id === root) {
            result.push(map[id])
        } else {
            map[parent_id].children.push(map[id])
        }
    }
    return result;
 }
```

# 17 实现lodash的set和get方法
`set`方法可以根据提供的路径(以点分割)设置对象的值，如果路径上嵌套的对象不存在，则会递归创建
`get`方法可以根据提供的路径获取对象上的值，如果路径上的某个键不存在或对象中断，返回undefined
```javascript
function set(object, path, value) {
  const keys = path.split('.');
  let current = object;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (!(key in current)) {
      // Create nested objects if the key doesn't exist
      current[key] = {};
    }
    current = current[key];
  }

  current[keys[keys.length - 1]] = value;
}

function get(object, path) {
  const keys = path.split('.');
  let current = object;

  for (const key of keys) {
    if (typeof current !== 'object' || !(key in current)) {
      return undefined;
    }
    current = current[key];
  }

  return current;
}
```

# 18 实现一个批量请求函数，要求能够限制并发量
这道题比较有意思，其实就是要实现一个限制最大并发的Promise.all().
实现思路比较简单，就是在每次请求结束后，看队列是否还有未完成的请求，如果有，就按顺序进行下一个请求。
```javascript
function multiRequest(urls = [], maxNum) {
    // 请求总数量
    const sum = urls.length;
    // 根据请求数量创建一个数组来保存请求的结果
    const result = new Array(sum).fill(false);
    // 当前完成的数量
    let count = 0;

    return new Promise((resolve, reject) => {
        // 请求maxNum个
        while (count < maxNum) {
            next();
        }
        function next() {
            let current = count++;
            // 处理边界条件
            if (current >= sum) {
                // 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回
                !result.includes(false) && resolve(result);
                return;
            }
            const url = urls[current];
            console.log(`开始 ${current}`, new Date().toLocaleString());
            fetch(url).then(res => {
                // 保存请求结果
                result[current] = res;
                console.log(`完成 ${current}`, new Date().toLocaleString());
                // 请求没有全部完成, 就递归
                if (current < sum) {
                    next();
                }
            }).catch(err => {
                console.log(`结束 ${current}`, new Date().toLocaleString());
                result[current] = err;
                // 请求没有全部完成, 就递归
                if (current < sum) {
                    next();
                }
            });
        }
    });
}

const url = `https://www.baidu.com/s?wd=javascript`;
const urls = new Array(100).fill(url);

(async () => {
    const res = await multiRequest(urls, 10);
    console.log(res);
})();
```

# 19 树转数组
将以下结构的数据转成数组。
```javascript
const listTree = [
  {
    id: 1,
    name: '部门1',
    pid: 0,
    children: [
      {
        id: 2,
        name: '部门1-1',
        pid: 1,
        children: [
          {
            id: 4, 
            name: '部门1-1-1', 
            pid: 2,
            children: []
          }
        ]
      },
      {
        id: 3,
        name: '部门1-2',
        pid: 1,
        children: [
          {
            id: 5, 
            name: '部门1-2-1', 
            pid: 3,
            children: []
          }
        ]
      }
    ]
  },
  {
    id: 6,
    name: '部门2',
    pid: 0,
    children: [
      {
        id: 7, 
        name: '部门2-1', 
        pid: 6,
        children: []
      }
    ]
  },
  {
    id: 8,
    name: '部门3',
    pid: 0,
    children: []
  }
]
```
期望结果：
```javascript
const list = [
  {id: 1, name: '部门1', pid: 0},
  {id: 2, name: '部门1-1', pid: 1},
  {id: 3, name: '部门1-2', pid: 1},
  {id: 4, name: '部门1-1-1', pid: 2},
  {id: 5, name: '部门1-2-1', pid: 3},
  {id: 6, name: '部门2', pid: 0},
  {id: 7, name: '部门2-1', pid: 6},
  {id: 8, name: '部门3', pid: 0},
]
```
## 我的方法
```javascript
function transListTree(tree) {
    let res = []
    for(let i = 0; i < tree.length; i++) {
        const item = tree[i];
        const {id, name, pid, children} = item;
        res.push({id, name, pid})
        res.push(...transListTree(children || []))
    }
    return res;
}
transListTree(listTree)
```
reduce取树行数据的所有子集
```javascript
function treeTransList(tree, key) {
    return tree.reduce(function (con, item) {
        var callee = arguments.callee;
        con.push(item);
        if(item[key] && item[key].length > 0) {
            item[key].reduce(callee, con)
        }
        return con;
    },[]).map(function(item){
        item[key] = [];
        return item;
    })
}
treeTransList(listTree, 'children')
```
## 递归实现
```javascript
function getItem(tree, result) {
  for (let i = 0; i < tree.length; i++) {
    if(tree[i].children) {
      getItem(tree[i].children, result)
      delete tree[i].children;
    }
    result.push(tree[i])
  }
  return result;
}

function treeToList(tree) {
  const result = [];
  getItem(tree, result);
  return result;
}
treeToList(listTree)
```
 ## 广度优先遍历法
```javascript
function treeToList(tree, childName = 'children') {
  // 设置临时数组，用来存放队列
  let queen = [];
  // 设置输出数组，用来存放要输出的一维数组
  const result = [];
  queen = queen.concat(tree);
  // 对树对象进行广度优先的遍历
  while(queen.length) {
    const first = queen.shift();
    if (first[childName]) {
      queen = queen.concat(first[childName]);
      delete first[childName]
    }
    result.push(first);
  }
  return result;
}  
treeToList(listTree, 'children')
```

# 数组转树
将下列数组进行转换：
```javascript
const list = [
  {id: 1, name: '部门1', pid: 0},
  {id: 2, name: '部门1-1', pid: 1},
  {id: 3, name: '部门1-2', pid: 1},
  {id: 4, name: '部门1-1-1', pid: 2},
  {id: 5, name: '部门1-2-1', pid: 3},
  {id: 6, name: '部门2', pid: 0},
  {id: 7, name: '部门2-1', pid: 6},
  {id: 8, name: '部门3', pid: 0},
]
```
期望结果：
```javascript
const listTree = [
  {
    id: 1,
    name: '部门1',
    pid: 0,
    children: [
      {
        id: 2,
        name: '部门1-1',
        pid: 1,
        children: [
          {
            id: 4, 
            name: '部门1-1-1', 
            pid: 2,
            children: []
          }
        ]
      },
      {
        id: 3,
        name: '部门1-2',
        pid: 1,
        children: [
          {
            id: 5, 
            name: '部门1-2-1', 
            pid: 3,
            children: []
          }
        ]
      }
    ]
  },
  {
    id: 6,
    name: '部门2',
    pid: 0,
    children: [
      {
        id: 7, 
        name: '部门2-1', 
        pid: 6,
        children: []
      }
    ]
  },
  {
    id: 8,
    name: '部门3',
    pid: 0,
    children: []
  }
]

```
## 我的方法
```javascript
function listToTree(list, root) {
    return list.filter(item => item.pid === root)
        .map(item => ({...item, children: listToTree(list, item.id)}))
}
```
# 21 删除链表的一个节点
可以通过以下步骤实现：
- [x] 遍历链表，找到待删除节点的前一个节点
    
- [x] 将待删除节点的前一个节点的next指针指向待删除节点的下一个节点
- [x] 将待删除节点置为null
 下面是示例代码，假设链表的每个节点都有 val 和 next 两个属性：
```javascript
function deleteNode(head, val) {
  // 如果要删除的节点是头节点，则直接返回 head.next
  if (head.val === val) {
    return head.next;
  }

  let prev = head;
  let curr = head.next;

  while (curr !== null) {
    if (curr.val === val) {
      prev.next = curr.next;
      curr = null;
      break;
    } else {
      prev = curr;
      curr = curr.next;
    }
  }

  return head;
}
```
首先检查待删除节点是否为头节点。如果是，则直接返回头节点的下一个节点；否则，我们遍历链表并找到待删除节点的前一个节点和当前节点。

当找到该节点时，我们将前一个节点的 next 指针指向待删除节点的下一个节点，并将待删除节点置为 null，以便 JavaScript 的垃圾回收机制能够回收内存，避免内存泄漏。

最后，我们返回头节点作为函数的结果。
# 21 实现一个请求函数：fetchWithRetry，要求会最多自动重试 3 次，任意一次成功就直接返回
```javascript
function fetchWithRetry(url, options, maxRetry = 3) {
    return new Promise((resolve, reject) => {
        const doFetch = async (attempt) => {
            try {
                const response = await fetch(url, options);
                if (response.ok) {
                    resolve(response)
                } else {
                    throw new error('Request Failed');
                }
            } catch(error) {
                if (attemp < maxRetry) {
                    doFetch(attempt + 1);
                } else {
                    reject(new Error('Max retries exceeded'))
                }
            }
        }
        doFetch(0)
    })
}
```
# 22 计算出下面数组中的平均时间
将时间转换为分钟数，计算平均值后再将结果转换回小时和分钟即可。具体步骤如下：

遍历数组中的每个时间，将其转换为分钟数并求和。

将总分钟数除以时间数量得到平均值，取整数部分作为小时数，余数部分作为分钟数。

如果分钟数小于 10，则在前面添加一个零以保持两位数格式。

将小时数和分钟数组合成字符串形式的时间表示。
```javascript
const arr = ["8:15", "6:35", "11:22"];

// 1. 将时间转换为分钟数并求和
const totalMinutes = arr.reduce((acc, cur) => {
  const [hours, minutes] = cur.split(':');
  return acc + Number(hours) * 60 + Number(minutes);
}, 0);

// 2. 计算平均值并将结果转换回小时和分钟
const averageMinutes = Math.floor(totalMinutes / arr.length);
const hours = Math.floor(averageMinutes / 60);
const minutes = averageMinutes % 60;

// 3. 格式化分钟数
const formattedMinutes = minutes < 10 ? `0${minutes}` : `${minutes}`;

// 4. 组合成字符串形式的时间
const averageTime = `${hours}:${formattedMinutes}`;
console.log(averageTime); // 输出 "8:44"
```

# 23 实现 compose 函数, 类似于 koa 的中间件洋葱模型
```javascript
// 题目需求
let middleware = []
middleware.push((next) => {
    console.log(1)
    next()
    console.log(1.1)
})
middleware.push((next) => {
    console.log(2)
    next()
    console.log(2.1)
})
middleware.push((next) => {
    console.log(3)
    next()
    console.log(3.1)
})

let fn = compose(middleware)
fn()


/*
1
2
3
3.1
2.1
1.1
*/

//实现compose函数
function compose(middlewares) {
     // 校验传入的参数上数组，校验数组中的每一项是函数。
     if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
    for (const fn of middleware) {
        if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
    /**
   * @param {Object} context
   * @return {Promise}
   * @api public
   */

  return function (context, next) {
    // last called middleware #
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      // 一个函数中多次调用报错
      // await next()
      // await next()
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      // 取出数组里的 fn1, fn2, fn3...
      let fn = middleware[i]
      // 最后 相等，next 为 undefined
      if (i === middleware.length) fn = next
      // 直接返回 Promise.resolve()
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```
# 24 实现 compose 函数, 类似于 koa 的中间件洋葱模型
实现一个 compose 函数，它可以将多个中间件函数组合成一个函数，以便依次执行这些中间件，类似于 Koa 框架的洋葱模型。

在这个模型中，每个中间件函数接收 context 和 next 参数，context 用于共享数据，而 next 是一个函数，用于调用下一个中间件。执行顺序就像洋葱一样，从最外层到最内层，再从最内层返回到最外层。

实现代码
```javascript
function compose(middlewares) {
    return function (context, next) {
        // 定义一个执行函数，用于递归调用每个中间件
        function dispatch(index) {
            if (index >= middlewares.length) return Promise.resolve(); // 如果已经执行到最后一个中间件，结束
            const fn = middlewares[index];
            try {
                // 调用当前中间件，并传入上下文和下一个中间件的 dispatch 函数
                return Promise.resolve(fn(context, () => dispatch(index + 1)));
            } catch (err) {
                return Promise.reject(err);
            }
        }
        return dispatch(0); // 从第一个中间件开始执行
    };
}

```
使用示例
```javascrit
async function middleware1(ctx, next) {
    console.log('middleware1 start');
    await next(); // 调用下一个中间件
    console.log('middleware1 end');
}

async function middleware2(ctx, next) {
    console.log('middleware2 start');
    await next();
    console.log('middleware2 end');
}

async function middleware3(ctx, next) {
    console.log('middleware3 start');
    await next();
    console.log('middleware3 end');
}

const middlewares = [middleware1, middleware2, middleware3];
const composed = compose(middlewares);

composed({}, () => {
    console.log('all done');
}).then(() => {
    console.log('Middleware execution finished.');
}).catch(err => {
    console.error('Error:', err);
});

```
输出结果
运行上述代码将产生如下输出：
```javascript
middleware1 start
middleware2 start
middleware3 start
middleware3 end
middleware2 end
middleware1 end
all done
Middleware execution finished.

```
代码解释
compose 函数：compose 接收一个中间件数组 middlewares，返回一个函数，该函数接收 context 和 next 参数。

dispatch 函数：dispatch 函数用于递归执行中间件链。通过 index 来跟踪当前正在执行的中间件，并在每个中间件中调用 next，通过 dispatch(index + 1) 进入下一个中间件。

Promise：dispatch 函数返回一个 Promise，这样可以支持异步操作。

调用顺序：当 dispatch(0) 被调用时，compose 会从第一个中间件开始，依次执行每个中间件，并通过 await next() 实现洋葱模型中的先执行后返回的顺序。

# 25 请按以下要求实现方法 fn ：遇到退格字符就删除前面的字符，遇到两个退格就删除两个字符
```javascript
// 比较含有退格的字符串，"<-"代表退格键，"<"和"-"均为正常字符
// 输入："a<-b<-", "c<-d<-"，结果：true，解释：都为""
// 输入："<-<-ab<-", "<-<-<-<-a"，结果：true，解释：都为"a"
// 输入："<-<ab<-c", "<<-<a<-<-c"，结果：false，解释："<ac" !== "c"

function fn(str1, str2) {

}
```

## 我的答案
```javascript
function fn(str1, str2) {
    function getRes(str) {
        const n = str.length;
        let stack = [];
        for(let i = 0; i < n; i++) {
            if (str[i] === '<' && str[i+1] === '-') {
                stack.pop();
                ++i
            } else {
                stack.push(str[i])
            }
        }
        return stack.join('')
    }
    return getRes(str1) === getRes(str2)
}
fn("a<-b<-", "c<-d<-")
```

## 参考答案
```javascript
function fn(str1, str2) { 

  const doDelete = (str) => {
    let flag = 0;// 0 - 正常字符；1 - <；2 - <-
    const stack = [];
    for(let i = 0; i < str.length; i++) {
      const char = str[i];
      stack.push(char);

      if(char === '<' && !flag) {
        flag += 1
      } else if(flag === 1) {
        if(char === '-') {
          flag += 1
        } else {
          flag -= 1
        }
      }

      if(flag === 2) {
        stack.pop();
        stack.pop();
        stack.pop();
        flag = 0
      }
    }
    // console.log(String(stack))
    return String(stack);
  }

  return doDelete(str1) === doDelete(str2);
}

console.log(fn("a<-b<-", "c<-d<-"))
console.log(fn("<-<-ab<-", "<-<-<-<-a"))
console.log(fn("<-<ab<-c", "<<-<a<-<-c"))
```
# 26 不定长二维数组的全排列
给定任意二维数组，输出所有的排列组合项。

比如 [['A','B'], ['a','b'], [1, 2]]，输出 ['Aa1','Aa2','Ab1','Ab2','Ba1','Ba2','Bb1','Bb2']

## 我的答案
```javascript
function fullRange(arr){
    const m = arr.length;
    const n = arr[0].length;
    let dp = new Array(m).fill([]).map(() => new Array(n).fill(''))
    dp[0] = arr[0]
    function dfs(arr1,arr2) {
        let data = []
        for(let i = 0; i < arr1.length;i++) {
            for(let j = 0; j < arr2.length; j++) {
                data.push(`${arr1[i]}${arr2[j]}`)
            }
        }
        return data;
    }
    for(let i = 1; i < m; i++) {
        dp[i] = dfs(dp[i-1], arr[i])
    }
    
    return dp[m-1]
}
fullRange([['A','B'], ['a','b'], [1, 2]])
// (8) ['Aa1', 'Aa2', 'Ab1', 'Ab2', 'Ba1', 'Ba2', 'Bb1', 'Bb2']
```
## 参考答案
```javascript
可以采用动态规划的方式，下一次的结果，依赖上一次的结果，比如第一次的结果是 ['A', 'B'],下一个增加了 ['a', 'b'] 就可以在上一次的基础上变为 ['Aa', 'Ab', 'Ba', 'Bb']，依次类推
/**
 * 动态规划，下一次的结果，依赖上一次的结果
 * @param {array} arr 
 */
function permutate(arr) {
    // 第一次的结果就是二维数组的第0项
	let res = arr[0].slice();

	for (let i = 1; i < arr.length; i++) {
		const pre = res.slice();
		res = [];
		pre.forEach(item => {
			arr[i].forEach(curr => {
				res.push(item + curr)
			})
		});
	}
	console.log(res)
	return res;
}
```
多维数组的全排列问题，和全排列问题类似，但是不同于全排类问题。全排列问题使用的是DFS，而多维数组的全排列则使用的是动态规划，后一个结果依赖于前一个结果。


# 27 两个字符串对比, 得出结论都做了什么操作, 比如插入或者删除
```javascript
pre = 'abcde123'
now = '1abc123'
```
a前面插入了1, c后面删除了de

## 我的答案
```javascript
function operation (str1, str2){
    let insert = [];
    let deleted = [];
    let map = new Map();
    for(let i = 0; i < str1.length; i++) {
        map.set(str1[i], map.get(str1[i])??0 + 1)
    }
    for(let j = 0; j < str2.length; j++) {
        if(!map.get(str2[j])) {
            insert.push(str2[j])
        } else {
            map.set(str2[j], map.get(str2[j]) - 1)
        }
    }
    for (const [key, value] of map){
        if (value > 0) {
            deleted.push(key)
        }
    }
    return `插入${insert.join(',')}, 删除${deleted.join(',')}`;
}
operation('abcde123', '1abc123')
```
## 参考答案：
思路：编辑距离
动态规划求编辑距离
倒着将变化输出。dp[i] === dp[i - 1] + 1
```javascript
function compareStrings(pre, now) {
    const m = pre.length;
    const n = now.length;
    const dp = new Array(m + 1).fill().map(() => new Array(n + 1).fill(0));
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (pre[i - 1] === now[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
            }
        }
    }

    et i = m;
    let j = n;
    let diff = "";
    while (i > 0 || j > 0) {
        if (i > 0 && dp[i][j] === dp[i - 1][j] + 1) {
            diff = `删除${pre[i - 1]}, ${diff}`;
            i--;
        } else if (j > 0 && dp[i][j] === dp[i][j - 1] + 1) {
            diff = `插入${now[j - 1]}, ${diff}`;
            j--;
        } else {
            i--;
            j--;
        }
    }
    return diff;
}
const pre = 'abcde123';
const now = '1abc123';
const diff = compareStrings(pre, now);
console.log(diff); // 输出：插入1, 删除d, 删除e
```
解释：

我们将一个字符串转换成另一个字符串的操作分为三种：插入、删除、替换。在这个函数中，我们将删除操作定义为从 pre 字符串中删除一个字符，使得 pre 的前缀变为 now 的前缀。因此，在 dp 数组中，dp[i][j] 表示 pre 的前缀 pre[0...i-1] 变为 now 的前缀 now[0...j-1] 所需的最小操作次数。如果我们想要将 pre 的前缀 pre[0...i-1] 变为 now 的前缀 now[0...j-1]，可以有三种操作方式：

插入一个字符：我们可以在 pre 的前缀 pre[0...i-1] 的末尾插入一个字符 now[j-1]，这样就将 pre 的前缀变为 now 的前缀。此时，dp[i][j] 的值应该为 dp[i][j-1] + 1。
删除一个字符：我们可以将 pre 的前缀 pre[0...i-2] 变为 now 的前缀 now[0...j-1]，然后再删除字符 pre[i-1]，这样也能将 pre 的前缀变为 now 的前缀。此时，dp[i][j] 的值应该为 dp[i-1][j] + 1。
替换一个字符：我们可以将 pre 的前缀 pre[0...i-2] 变为 now 的前缀 now[0...j-2]，然后再将字符 pre[i-1] 替换为字符 now[j-1]，这样也能将 pre 的前缀变为 now 的前缀。此时，dp[i][j] 的值应该为 dp[i-1][j-1] + 1。 在这个函数中，我们根据 dp 数组的值，逆推出从 pre 转换成 now 的具体操作。如果 dp[i][j] 的值是由 dp[i-1][j] 转移而来，那么说明我们需要删除字符 pre[i-1]，以使得 pre 的前缀变为 now 的前缀。因此，我们在返回字符串中加入 删除pre[i-1] 的操作。

# 28 实现一个方法，从某个数值数组中，获取最小正数（非零非负数）的索引值
## 我的答案
```javascript
function getMinIndex(arr) {
    const n = arr.length;
    let min = -1;
    for(let i = 0; i < n; i++) {
        if ((min === -1 && arr[i] > 0) || (min > 0 && arr[min] > arr[i] && arr[i] > 0)) {
            min = i;
        }
    }
    return min === -1 ? -1 : min;
}
getMinIndex([]) // -1
getMinIndex([-1,-2,-3,-4,-5]) // -1
getMinIndex([-1,2,3,4,5]) // 1
```
 ## 二
```javascript
function findNoneZeroMinIndex(arr) {
    let min = Infinity;
    let idx = -1
    for(let i = 0; i < arr.length; i++) {
        if (arr[i] > 0 && arr[i] < min) {
            min = arr[i]
            idx = i
        }
    }
    return idx;
}
```
## 参考答案
```javascript
function findNonZeroMinIndex(arr) {
  let min = Infinity;
  let index = -1;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > 0 && arr[i] < min) {
      min = arr[i];
      index = i;
    }
  }
  return index;
}
```
使用循环和条件判断来遍历数组，查找满足条件（即非零非负数）并且值最小的元素，并返回其索引。

如果数组中没有满足条件的元素，则返回 -1。
# 29 实现一个等待函数，支持让 async 函数在执行时暂停一段时间，函数的入参为暂停的时间
## 我的答案
```javascript
function sleep(timer) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(), timer * 1000)
    })
}
```
## 参考答案：
在使用 async/await 时，可以用 await 关键字等待一个 Promise 对象的结果，然后执行一些操作。在等待过程中，函数会暂停执行，直到 Promise 对象的状态发生改变。

下面是一个示例代码，其中定义了一个名为 wait 的等待函数，它可以让 async 函数在执行时暂停一段时间：
```javascript
function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function run() {
  console.log('start');
  await wait(2000); // 等待2秒钟
  console.log('end');
}

run();
```

# 39 使用正则表达式实现以下需求：筛选出数组中只包含大小写字母的字符串，并将结果转换成大写

## 我的答案
```javascript
function filterChar(arr) {
    return arr.filter(item => /^[a-zA-Z]+$/.test(item)).map(item => item.toUpperCase(item))
}
filterChar(['aBc','123','a23'])
```
## 参考答案
可以先使用正则表达式 /^[a-zA-Z]+$/ 来匹配只包含大小写字母的字符串，使用 Array.prototype.filter() 方法来筛选符合条件的元素，然后使用 Array.prototype.map() 方法将每个元素转换成大写，最终得到了一个新的数组 filteredArr。

参考代码如下：
```javascript
const arr = ['Abc', 'DeF', '123', '_ghI'];

const filteredArr = arr.filter(item => /^[a-zA-Z]+$/.test(item))
                       .map(item => item.toUpperCase());

console.log(filteredArr); // ["ABC", "DEF"]
```

# 31 实现一个将多维数组展示的方法
参考答案：

方法一：ES6新增的数组扩展方法flat()
```javascript
let arr = [1,2,3,[4,5],6];
let res = arr.flat();//[1,2,3,4,5,6]
```
可能会有小伙伴说flat()默认只能拉伸一层，如果需要处理的是多层嵌套数组呢？
```javascript
let arr1 = [1,2,3,[4,5,[6,7]],8];
let res1 = arr.flat(3); //参数3代表三维数组的展开，结果为[1,2,3,4,5,6,7,8]

let arr2 = [1,2,3,[4,5,[6,7,[8]]],9];
let res2 = arr2.flat(4); //参数4代表思维数组的展开，结果为[1,2,3,4,5,6,7,8,9]

......
```
不过这样处理的话，对于已知的数组维度是可以处理的，那么对于未知嵌套层级的数组是相当不友好的，那么针对未知的多维嵌套数组我们应该用什么方法展开呢？看代码：
```javascript
let arr3 = [1,2,3,[4,5,[6,7,[8]]],9];
let res3 = arr3.flat(Infinity); //参数为Infinity,结果为[1,2,3,4,5,6,7,8,9]
```
这样不管你要处理的数组是几层嵌套关系，都会处理成你想要的一维数组。

方法二：apply()结合concat()使用以展开成一维数组
```javascript
let arr4 = [1,2,3,[4,5],6];
let res4 = [].concat.apply([],arr4);//结果为[1,2,3,4,5,6]
```
这个方法虽然可以处理，不过有一个缺陷需要指出，那就是该方法只能将二维数组展开为一维，二维以上的多维数组的处理就需要循环遍历一层层的使用该方法了，有点麻烦，如果想使用简单的方法，请参考方法一。

方法三：reduce()结合concat()方法
```javascript
let arr5 = [[0, 1], [2, 3]];
let res5 = arr5.reduce(
  (acc, cur) => {
    return acc.concat(cur);
  }
);//结果为[0,2,3,4]
```
需要注意的是此方法和方法二类似，处理多维数组的时候需要进行其他处理。

方法四：针对方法一和方法二的缺陷，可以使用递归的方法进行展开
```javascript
let arr6 = [1,2,[3,4,[5,6],7],8]
function flatten(arr){
	let res6 = [];
	for(let i=0; i < arr.length; i++){
		if(Array.isArray(arr[i])){
			res6 = res6.concat(flatten(arr[i])) 
		}else{
			res6.push(arr[i])
		}
	}
	return res6;
}
Flatten(arr6);//结果为[1,2,3,4,5,6,7,8]
```
方法五：使用toString()和split(',')方法

如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：toString会将数组中的数以逗号形式结合起来。toString()之后再split(',')转成数组，并将其转换回数字数组：
```javascript
var arr = [1, [2, [3, 4],[5,[6],[7,8]]]];
var arrStr = arr.toString();
console.log(arrStr);//1,2,3,4,5,6,7,8
var strArr = arrStr.split(',');
console.log(strArr)//["1", "2", "3", "4", "5", "6", "7", "8"]
```
该方法只适用于数组内全部是数字的情况。

方法六：使用reduce和concat方法，结合递归，利用重写原型的另一种方法
```javascript
Array.prototype.flatten=function(){
  return this.reduce(function(prev, cur) {
    var moreArr = [].concat(cur).some(Array.isArray); //判断cur是不是一个数组
    return prev.concat(moreArr ? cur.flatten() : cur);
  },[]);
};
var bbb = [1,2,3,[4,[5,6,[7,8]]]]
var ccc=bbb.flatten();
console.log(ccc);//结果为[1, 2, 3, 4, 5, 6, 7, 8]
```
方法七：es6扩展运算符
```javascript
function flatten(arr){
  while(arr.some(item=>Array.isArray(item))){
    arr = [].concat(...arr);
  }
  return arr;
}
var sunArr = [1,2,3,[4,[5,[6]]]];
flatten(sunArr);//结果为 [1, 2, 3, 4, 5, 6]
```


# 32 使用TS实现一个判断传入参数是否是数组类型的方法
unknown 用于变量类型不确定，但肯定可以确定的情形下，比如下面这个示例中，参数总归会有个值，根据这个值的类型进行不同的处理，这里使用 unknown 替代 any 则会更加类型安全。
```javascript
function isArray(x: unknown): boolean {
	return Array.isArray(x)
}
```

# 33 给某个资源的链接，如 https://www.baidu.com/index.html ，请实现一个方法，获取该资源的后缀，如 html
本题主要考察字符串相关的方法，实现比较简单，下面列举两个实现方法。
```javascript
var fileName = "https://www.baidu.com/index.html";

function getFileExtension(url){
	if(typeof url !== 'string'){
    	return ''
    }
    
    // 方法一
    return url.substring(url.lastIndexOf('.') + 1);
    
    // 方法二
    return url.split('.').pop()
```

# 34 根据运算优先级添加括号
现已知一个字符串是由正整数和加减乘除四个运算符(+ - * /)组成。

例如存在字符串 const str = '11+2-3*4+5/2*4+10/5'，现在需要将高优先级运算，用小括号包裹起来，例如结果为 '11+2-(3*4)+(5/2*4)+(10/5)'。注意可能会出现连续的乘除运算，需要包裹到一起。

请用 javascript 实现这一过程
## 我的回答：
```javascript
function transOperate(str) {
    let slow = 0;
    let res = ''
    let highFlag = false;
    let operators = ['+', '-', '*', '/'];
    let highOperators = ['*', '/']
    for(let fast = 0; fast < str.length; fast++) {
        if (operators.includes(str[fast])) {
            if (highOperators.includes(str[fast])) {
                const brackets = highFlag ? '' : '('
                res = res + brackets + str.substring(slow, fast+1)
                highFlag = true;
            } else {
                const brackets = highFlag ? ')' : ''
                res = (res + str.substring(slow, fast)) + brackets + str[fast]
                highFlag = false;
            }
            slow = fast + 1;
        }
    }
    res = res + str.substring(slow) + (highFlag ? ')' : '')
    return res;
}
transOperate('11+2-3*4+5/2*4+10/5')
```

## 参考答案
介绍一种只需遍历一次的实现方式，思路比较简单，主要用到了2个临时变量，分别用于记录当前是否在高优先级运算范围和临时值，然后根据不同优先级的运算符进行不同的处理操作。

具体的代码如下：
```javascript
function addBrackets(expression) {
 const resultArr = []

 // 定义运算符
 const symbolArr = ['+', '-', '*', '/']

 // 定义高优先级运算符
 const highLevelSymbolArr = ['*', '/']

 // 判断某个字符串是否是运算符
 const isSymbolFn = (str) => symbolArr.includes(str)

 // 判断某个字符串是否是高优先级运算符
 const isHighLevelSymbolFn = (str) => highLevelSymbolArr.includes(str)

 // 输入表达式的长度
 const expLen = expression.length

 // 标记当前的遍历是否处于高优先级运算符范围
 let isInBracket = false
 // 记录临时值
 let currentNum = ''

 for (let i = 0; i < expLen; i++) {
   const isSymbol = isSymbolFn(expression[i])
   const isHighLevelSymbol = isSymbol && isHighLevelSymbolFn(expression[i])

   // 处理当前字符是运算符的场景
   if (isSymbol) {
     //处理当前字符是高优先级运算符
     if (isHighLevelSymbol) {
       // 如果当前没有被标记为高优先运算符，就在前面加个括号
       if (!isInBracket) {
         currentNum = '(' + currentNum
       }

       // 修改标记状态
       isInBracket = true
       currentNum += expression[i]
     } else {
       // 普通运算符

       if (isInBracket) {
         // 如果之前已经在高优先级运算符范围，就需要标记结束
         resultArr.push(currentNum + ')')
         isInBracket = false
       } else {
         resultArr.push(currentNum)
       }
       resultArr.push(expression[i])
       currentNum = ''
     }
   } else {
     // 如果是数字，就直接进行记录
     currentNum = currentNum + expression[i]
   }
 }

 if (currentNum) {
   resultArr.push(currentNum + (isInBracket ? ')' : ''))
 }

 return resultArr.join('')
}
```
 使用正则实现（2022/10/30更新）
```javascript
let text = '11+2-34+5/24+10/5+10/512'; 
text.match(/([0-9]{1,}[*|/]){1,}[0-9]{1,}/g).forEach((item)=>{ 
	text = text.replace(item,`(${item})`) 
})
console.log(text); // '11+2-34+(5/24)+(10/5)+(10/512)'
```


# 35 请对以下数组，根据 `born` 的值降序排列
```javascript
function compare(a, b) {
  return a.born < b.born ? 1: -1 
}

singers.sort(compare);

// 也可以进行简写
singers.sort((a,b) => b.born - a.born)

```

# 36 编程实现温度转换，已知温度转换的关系式是：华氏度＝32＋摄氏度×1.8，现在要求输入摄氏度，输出对应的华氏度，小数保留两位

```javascript
function convertTemperature(centigrade){
   if(typeof centigrade !== 'number'){
   	throw new Error('Wrong parameter type!')
   }

   return (32 + centigrade * 1.8).toFixed(2)
}
```

# 37 用es5如何实现 let 和 const ？
实现 let
let 大家应该用的非常熟悉了，定义一个仅作用于该代码块的变量。如果去 babel 上面在线转换一下，大家可以看到结果是 var。在 es6 出现以前我们一般使用无限接近闭包的形式或者立即执行函数的形式来定义不会被污染的变量。

我们这也可以做类似的操作。
```javascript
(function(){
	var a = 1;
    console.log(a)
})();

console.log(a)
```
效果不错，这大概也是使用 es6 的方便之处吧。

实现 const
那么 const 该怎么实现呢？

const 声明一个只读的常量。一旦声明，常量的值就不能改变。

有什么方法是可以限制一个值不能发生改变的呢？

是的,需要用到 Object.defineProperty。

其中有一个属性是这样的：

writable：当前对象元素的值是否可修改。

由于 ES5 环境没有 block 的概念，所以是无法百分百实现 const，只能是挂载到某个对象下，要么是全局的 window，要么就是自定义一个 object 来当容器
```javascript
var __const = function __const(data, value) {
  window.data = value // 把要定义的data挂载到window下，并赋值value
  Object.defineProperty(window, data, { // 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符
    enumerable: false,
    configurable: false,
    get: function () {
      return value
    },
    set: function (data) {
      if (data !== value) { // 当要对当前属性进行赋值时，则抛出错误！
        throw new TypeError('Assignment to constant variable.')
      } else {
        return value
      }
    }
  })
}
__const('a', 10)
console.log(a)
delete a
console.log(a)
for (let item in window) { // 因为const定义的属性在global下也是不存在的，所以用到了enumerable: false来模拟这一功能
  if (item === 'a') { // 因为不可枚举，所以不执行
    console.log(window[item])
  }
}
a = 20 // 报错
```
代码有点略长，但是还算通透。那。。还有没有更简单一点的实现方法呢？至少不要这么长的代码demo了。答案是肯定的，只不过没有上面例子那么透彻。我们这次将用到es5的

```javascript
Object.freeze();

var f = Object.freeze({'name':'admin'});
f.name = 'hello'; // 严格模式下是会报错的
f.name; // 打印出admin ,值没有被改变
```
想要的效果还是出来了，可以大概的定义一个常量了。

那么一个新的问题来了，const 真的定义的一定是一个常量嘛？一定是不可变的嘛？我们看看代码的结果

const a ={};
a.name='admin';
a.name // admin;

const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。

对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。

但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。

因此，将一个对象声明为常量必须非常小心。

带来的新特性
let,const问世之前，js是没有块级作用域这种特性的，只有函数作用域，导致了很多稀奇古怪的bug。

这里就要理解两个的区别，函数作用域好理解，就是函数{}包裹的区域，其实这里使用var，let，const都一样，外部是不能调用函数内部的变量的。

但是块级就有区别了，最明显的就是if(){}。在函数内使用条件判断，花括号内使用let,const,那么条件外是访问不到条件内的变量的，代码就会更清晰一点。

# 38 手写一个 jsonp
JSONP 核心原理：script 标签不受同源策略约束，所以可以用来进行跨域请求，优点是兼容性好，但是只能用于 GET 请求；
```javascript
const jsonp = ({ url, params, callbackName }) => {
    const generateUrl = () => {
        let dataSrc = ''
        for (let key in params) {
            if (params.hasOwnProperty(key)) {
                dataSrc += `${key}=${params[key]}&`
            }
        }
        dataSrc += `callback=${callbackName}`
        return `${url}?${dataSrc}`
    }
    return new Promise((resolve, reject) => {
        const scriptEle = document.createElement('script')
        scriptEle.src = generateUrl()
        document.body.appendChild(scriptEle)
        window[callbackName] = data => {
            resolve(data)
            document.removeChild(scriptEle)
        }
    })
}
```


# 39 要用二分查找的方法计算 √2，并且要求误差小于 10的-6次方
## 我的方法
```javascript
function findGenhao2(){
    let l = 1, r = 2;
    while(l + 2 * Math.pow(10, -6) < r) {
        let m = (l + r) / 2;
        if (Math.pow(m, 2) < 2) {
            l = m
        } else {
            r = m
        }
    }
    return {l, r}
}
findGenhao2()
```

# 40

Venenatis cras sed felis eget velit. Consectetur libero id faucibus nisl tincidunt. Gravida in fermentum et sollicitudin ac orci phasellus egestas tellus. Volutpat consequat mauris nunc congue nisi vitae. Id aliquet risus feugiat in ante metus dictum at tempor. Sed blandit libero volutpat sed cras. Sed odio morbi quis commodo odio aenean sed adipiscing. Velit euismod in pellentesque massa placerat. Mi bibendum neque egestas congue quisque egestas diam in arcu. Nisi lacus sed viverra tellus in. Nibh cras pulvinar mattis nunc sed. Luctus accumsan tortor posuere ac ut consequat semper viverra. Fringilla ut morbi tincidunt augue interdum velit euismod.

## Lorem Ipsum

Tristique senectus et netus et malesuada fames ac turpis. Ridiculous mus mauris vitae ultricies leo integer malesuada nunc vel. In mollis nunc sed id semper. Egestas tellus rutrum tellus pellentesque. Phasellus vestibulum lorem sed risus ultricies tristique nulla. Quis blandit turpis cursus in hac habitasse platea dictumst quisque. Eros donec ac odio tempor orci dapibus ultrices. Aliquam sem et tortor consequat id porta nibh. Adipiscing elit duis tristique sollicitudin nibh sit amet commodo nulla. Diam vulputate ut pharetra sit amet. Ut tellus elementum sagittis vitae et leo. Arcu non odio euismod lacinia at quis risus sed vulputate.
