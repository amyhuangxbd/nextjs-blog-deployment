---
title: "编程题"
excerpt: "手写编程题"
coverImage: "${basePath}/assets/blog/hello-world/cover.jpg"
date: "2020-03-16T05:35:07.322Z"
author:
  name: "Hebe Huang"
  picture: "${basePath}/assets/blog/authors/hebe.avif"
ogImage:
  url: "${basePath}/assets/blog/hello-world/cover.jpg"
---

# 1、如何实现一个bind?
```javascript
Function.prototype.myBind = function(context) {
    if (typeof this !== function) {
        throw new TypeError('Error')
    }
    let args = [...arguments].slice(1),
        fn = this;
    return function Fn() {
        return fn.apply(this instanceof Fn ? new Fn(...arguments)) : context, args.concat(...arguments)))
    }
}
```

# 2. 怎么实现浅拷贝
```javascript
fuction shadowClone(obj){
    let newObj = {}
    // 遍历传入对象的所有可枚举属性
    for(let prop in obj) {
        // 判断属性是否是对象自身的属性，而不是原型链上的
        if (obj.hasOwnProperty(prop)) {
            // 将该属性及其对应值复制到新对象中
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}
```

# 3. 怎么实现深拷贝
```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```

# 4, 用js实现二叉树的定义和基本操作
```javascript
class Node{
    constructor(data, left, right){
        this.data = data;
        this.left = left;
        this.right = right;
        this.count = 1;
    }
}
```
```javascript
class BSTree {
    constructor() {
        this.root = null
    }

    // 删除一个节点
    _removeNode(node, data){
        if (node === null) {
            return null;
        }
        if (data === node.data) {
            // 叶子节点
            if (node.left === null && node.right === null) {
                return null;
            }

            // 没有左节点的节点
            if (node.left === null) return node.right

            // 没有右节点的节点
            if (node.right === null) return node.left

            // 有两个节点的节点
            /**
             * 做法：
             * 找到待删除节点的右子树上的最小值创建一个临时节点。
             * 将临时节点上的值复制到待删除节点，然后再删除临时节点
             * 
            */

            // 寻找右子树上的最小值
            let tempNode = getMinNode(node.right);
            node.data = tempNode.data;
            node.right = this._removeNode(node.right, tempNode.data)
            return node;
        } else if (data < node.data) {
            node.left = this._removeNode(node.left, data)
            return node;
        } else {
            node.right = this._removeNode(node.right, data);
            return node;
        }
    }

    // 删除给定的数据节点
    remove(data) {
        this.root = this._removeNode(this.root, data)
    }

    // 向二叉树中插入节点
    insert(data){
        let newNode = new Node(data, null, null);
        if (this.root === null) {
            this.root = newNode;
        } else {
            let currentNode = this.root;
            let parentNode = null
            while(true) {
                parentNode = currentNode;
                if (newNode.data < currentNode.data) {
                    currentNode = currentNode.left;
                    if (!currentNode) {
                        parentNode.left = newNode
                        break;
                    }
                } else if (newNode.data > currentNode.data) {
                    currentNode = currentNode.right;
                    if (!currentNode) {
                        parentNode.right = newNode
                        break;
                    }
                } else {
                    currentNode.count++
                    break;
                }
            }
        }
    }

    // 寻找给定数据的节点
    find(data) {
        let currentNode = this.root;
        while(currentNode) {
            if (data < currentNode.left) {
                currentNode = currentNode.left;
            } else if (data > currentNode.right) {
                currentNode = currentNode.right;
            } else {
                return currentNode
            }
        }
        return null
    }

    // 获得最小值的节点
    getMinNode(node = this.root){
        let currentNode = node;
        while(currentNode.left) {
            currentNode = currentNode.left;
        }
        return currentNode
    }

    // 获得最大值的节点
    getMaxNode(node = this.root){
        let currentNode = node;
        while(currentNode.right) {
            currentNode = currentNode.right;
        }
        return currentNode
    }
}
```
[链接](https://fe.ecool.fun/topic/68c29b20-6b2f-4efa-b6f7-772cc7958084?orderBy=updateTime&order=desc&tagId=26)


Venenatis cras sed felis eget velit. Consectetur libero id faucibus nisl tincidunt. Gravida in fermentum et sollicitudin ac orci phasellus egestas tellus. Volutpat consequat mauris nunc congue nisi vitae. Id aliquet risus feugiat in ante metus dictum at tempor. Sed blandit libero volutpat sed cras. Sed odio morbi quis commodo odio aenean sed adipiscing. Velit euismod in pellentesque massa placerat. Mi bibendum neque egestas congue quisque egestas diam in arcu. Nisi lacus sed viverra tellus in. Nibh cras pulvinar mattis nunc sed. Luctus accumsan tortor posuere ac ut consequat semper viverra. Fringilla ut morbi tincidunt augue interdum velit euismod.

## Lorem Ipsum

Tristique senectus et netus et malesuada fames ac turpis. Ridiculous mus mauris vitae ultricies leo integer malesuada nunc vel. In mollis nunc sed id semper. Egestas tellus rutrum tellus pellentesque. Phasellus vestibulum lorem sed risus ultricies tristique nulla. Quis blandit turpis cursus in hac habitasse platea dictumst quisque. Eros donec ac odio tempor orci dapibus ultrices. Aliquam sem et tortor consequat id porta nibh. Adipiscing elit duis tristique sollicitudin nibh sit amet commodo nulla. Diam vulputate ut pharetra sit amet. Ut tellus elementum sagittis vitae et leo. Arcu non odio euismod lacinia at quis risus sed vulputate.
